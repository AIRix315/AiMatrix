# V0.4.0 全局架构对齐方案

> **创建时间**: 2026-01-07
> **更新时间**: 2026-01-07
> **方案类型**: 全局重构（非局部修复）
> **核心原则**: 模型优先、Provider路由、系统插件分离
> **整合原则**: 多余删除、不足补充、职能单一化

---

## 一、架构分层与职责

### 1.0 与现有架构的整合关系

**现有服务保留**：
- `ProviderHub` - 统一门面（保留）
- `ProviderRouter` - 操作类型到 Provider 的路由（保留）
- `ProviderRegistry` - Provider 实例注册和查询（保留）

**新增能力**：
- `Adapter` - 具体的 API 调用格式适配（新增）
- `APIManager.callModel()` - 统一模型调用入口（扩展）

**调用链**：
```
插件 → APIManager.callModel()
     → 查询支持该模型的 Provider（通过 category + models 匹配）
     → 根据 Provider.apiFormat 选择 Adapter
     → Adapter 执行具体 API 调用
     → 返回统一格式结果
```

**职责分工**：
| 服务 | 职责 | 状态 |
|------|------|------|
| ProviderRegistry | Provider 实例注册和查询 | 保留 |
| ProviderRouter | 操作类型路由 | 保留 |
| ProviderHub | 统一门面 | 保留 |
| **Adapter** | API 格式适配和调用 | **新增** |
| APIManager | Provider 配置管理 + callModel | **扩展** |

### 1.1 系统层（MATRIX Studio核心）

**职责**：
- 模型注册与管理（ModelRegistry）
- Provider全局路由（APIManager + 适配器）
- 资产存储与索引（AssetManager）
- 异步任务轮询（AsyncTaskManager）
- 项目配置管理（ProjectManager）

**提供能力**：
```typescript
// 统一模型调用接口
apiManager.callModel({
  model: "sora-2",
  category: APICategory.VIDEO_GENERATION,
  input: { prompt, imagePath }
})

// 自动路由逻辑
支持该模型的Provider → 按优先级排序 → 选择最优 → 适配器调用
```

**关键文件**：
- `src/main/services/APIManager.ts` - 核心路由
- `src/main/adapters/` - API格式适配器
- `src/main/services/ModelRegistry.ts` - 模型注册表
- `src/shared/types/api.ts` - 类型定义

### 1.2 插件层（Novel-to-Video）

**职责**：
- 实现N8N工作流5阶段逻辑
- 配置所需模型（不配置Provider）
- 调用系统提供的统一接口
- 管理工作流状态和进度

**不应包含**：
- ❌ Provider具体实现（如JiekouAIProvider.ts）
- ❌ API端点硬编码
- ❌ 供应商特定逻辑

**关键文件**：
- `plugins/official/novel-to-video/default-config.json` - 模型配置
- `plugins/official/novel-to-video/src/services/WorkflowExecutor.ts` - 工作流编排
- `plugins/official/novel-to-video/src/services/MaterialCollector.ts` - 进度管理

---

## 二、N8N工作流对齐

### 2.1 工作流阶段映射

| N8N阶段 | MATRIX实现 | 系统能力 | 插件逻辑 |
|---------|-----------|---------|---------|
| **Stage 0**: 配置初始化 | ProjectManager | 加载project.json配置 | 读取模型配置 |
| **Stage 1**: 场景分解 | APIManager.callModel(gpt-4) | LLM调用路由 | 结构化输出解析 |
| **Stage 2**: 并行物料生成 | AsyncTaskManager | 异步轮询机制 | 角色/场景图片批量生成 |
| **Stage 2.5**: 场景摘要 | APIManager.callModel(gpt-4) | LLM调用路由 | 100字摘要生成 |
| **Stage 3**: 分镜脚本 | APIManager.callModel(gpt-4) | LLM调用路由 | AI链式调用（4步） |
| **Stage 4**: 资产生成 | AsyncTaskManager | 异步轮询机制 | 图生图/视频生成 |

### 2.2 关键技术点对齐

**异步轮询**：
- N8N: Wait 10秒 → 查询状态 → 循环
- MATRIX: AsyncTaskManager已实现（10秒间隔、10分钟超时、重试机制）
- 对齐方式: 插件直接使用AsyncTaskManager，无需重复实现

**批量处理**：
- N8N: Loop Over Items（串行）
- MATRIX: 插件for循环调用apiManager.callModel()
- 对齐方式: 保持串行逻辑，确保任务独立失败不影响其他

**阀门机制**：
- N8N: 检查必要产出才能进入下一阶段
- MATRIX: WorkflowExecutor.checkGateCondition()
- 对齐方式: 已实现，保持不变

---

## 三、需删除的错误实现

### 3.1 插件内Provider实现（死代码）

**删除文件**：
```
plugins/official/novel-to-video/src/services/providers/ (整个目录)
```

**实际情况说明**：
- `JiekouAIProvider.ts` 定义了 `jiekou-ai-t2i`, `jiekou-ai-i2i`, `jiekou-ai-video` 三个 Provider
- **但这些 Provider ID 在代码中从未被调用**（死代码）
- 实际使用的是 `t8star-image`, `t8star-video`（在 NovelVideoAPIService.ts 中硬编码）

**原因**：死代码应删除，避免维护混乱

### 3.2 双重配置结构（冗余配置）

**删除配置**：
```json
// default-config.json 中的 workflow.providers 部分 - 删除
"workflow": {
  "providers": {
    "imageProvider": { "providerId": "jiekou-ai-t2i" },
    "i2iProvider": { "providerId": "jiekou-ai-i2i" },
    "videoProvider": { "providerId": "jiekou-ai-video" }
  }
}
```

**实际情况说明**：
- 此配置与顶层 `providers` 配置冲突
- 且这些 `jiekou-ai-*` Provider ID 在代码中从未被使用

**原因**：冗余配置造成混乱，应删除

### 3.3 硬编码供应商ID（违反模型优先原则）

**NovelVideoAPIService.ts 详细问题清单**：

| 行号 | 问题描述 | 修改方式 |
|------|---------|---------|
| 11 | `import { JiekouAIProvider }` | 删除导入 |
| 52-73 | `registerProviders()` 注册 JiekouAI | 删除整个方法 |
| 99-115 | 硬编码默认 Provider ID (`t8star-image`, `t8star-video`) | 改为从配置读取模型名称 |
| 167 | `if (providerId === 't8star-image')` | 改为 `callModel()` |
| 254 | `if (providerId === 't8star-image')` | 改为 `callModel()` |
| 343 | `if (providerId === 't8star-video')` | 改为 `callModel()` |
| 430 | `callRunningHubTTS` (不存在的方法) | 删除或抛出明确错误 |
| 467 | `JiekouAIProvider.imageToImage` 直接调用 | 改为 `callModel()` |

**修改方式**：
- 移除硬编码 Provider ID，改为从配置读取模型名称
- 移除供应商特定判断，改用统一的 `apiManager.callModel()` 调用
- 移除不存在方法的调用，避免运行时错误

### 3.4 孤立方法调用（运行时错误风险）

**问题代码**：
```typescript
// NovelVideoAPIService.ts 中调用了不存在的方法
audioPath = await this.apiManager.callRunningHubTTS({...});
```

**实际情况**：`callRunningHubTTS()` 方法在 APIManager 中不存在，会导致运行时错误

**处理方式**：
- 删除该调用，或抛出明确的"TTS 功能已迁移到工作流模式"错误
- TTS 配置中已标记 `optional: true`，可安全移除

---

## 四、需新增的系统能力

### 4.1 API格式适配器层

**目标**：按API格式分类，不按供应商

**新增文件**：

#### `src/main/adapters/BaseAdapter.ts`
```typescript
export interface AdapterCallParams {
  provider: APIProviderConfig;
  model: string;
  input: Record<string, unknown>;
}

export abstract class BaseAdapter {
  abstract get supportedFormat(): string;
  abstract callAPI(params: AdapterCallParams): Promise<unknown>;

  protected async fetch(url: string, options: RequestInit): Promise<Response> { }
  protected buildAuthHeader(provider: APIProviderConfig): Record<string, string> { }
}
```

#### `src/main/adapters/OpenAICompatibleAdapter.ts`
**支持**：T8Star、OpenAI、SiliconFlow、Ollama等

```typescript
export class OpenAICompatibleAdapter extends BaseAdapter {
  get supportedFormat(): string { return 'openai-compatible'; }

  async callAPI(params: AdapterCallParams): Promise<unknown> {
    if (params.provider.category === 'llm') {
      return await this.callLLM(params);
    } else if (params.provider.category === 'image-generation') {
      return await this.callImageGeneration(params);
    } else if (params.provider.category === 'video-generation') {
      return await this.callVideoGeneration(params);
    }
  }

  private async callLLM(params): Promise<{ text: string }> {
    const response = await this.fetch(`${params.provider.baseUrl}/chat/completions`, {
      method: 'POST',
      headers: this.buildAuthHeader(params.provider),
      body: JSON.stringify({
        model: params.model,
        messages: params.input.messages,
        temperature: params.input.temperature ?? 0.7,
        max_tokens: params.input.maxTokens ?? 2000
      })
    });
    const data = await response.json();
    return { text: data.choices[0].message.content };
  }

  private async callImageGeneration(params): Promise<{ imageUrl: string }> { }
  private async callVideoGeneration(params): Promise<{ videoUrl: string; taskId?: string }> { }
  private async pollTaskStatus(provider, taskId: string): Promise<string> { }
}
```

#### `src/main/adapters/AsyncPollingAdapter.ts`
**支持**：异步轮询格式（JiekouAI、部分 T8Star 异步接口等）

> **命名说明**：按功能特性命名，不使用供应商名称，便于复用和扩展

```typescript
export class AsyncPollingAdapter extends BaseAdapter {
  get supportedFormat(): string { return 'async-polling'; }

  async callAPI(params: AdapterCallParams): Promise<unknown> {
    const endpoint = this.getEndpointByModel(params.model, params.provider.category);

    const response = await this.fetch(endpoint, {
      method: 'POST',
      headers: this.buildAuthHeader(params.provider),
      body: JSON.stringify({
        prompt: params.input.prompt,
        image_size: params.input.size ?? '1024*1024',
        image_url: params.input.imagePath
      })
    });

    const data = await response.json();
    return await this.pollTaskStatus(params.provider, data.data.task_id);
  }

  private getEndpointByModel(model: string, category: string): string {
    const endpoints = {
      'z-image-turbo': 'https://api.jiekou.ai/v3/async/z-image-turbo',
      'sora-2': 'https://api.jiekou.ai/v3/async/sora-2-video-reverse',
      'nano-banana-pro': 'https://api.jiekou.ai/v3/nano-banana-pro-light-i2i'
    };
    return endpoints[model] || `https://api.jiekou.ai/v3/async/${model}`;
  }

  private async pollTaskStatus(provider, taskId: string): Promise<{ imageUrl?: string; videoUrl?: string }> { }
}
```

#### `src/main/adapters/ComfyUIWorkflowAdapter.ts`
**支持**：ComfyUI本地/云端工作流格式

```typescript
export class ComfyUIWorkflowAdapter extends BaseAdapter {
  get supportedFormat(): string { return 'comfyui-workflow'; }

  async callAPI(params: AdapterCallParams): Promise<unknown> {
    const workflowPayload = {
      prompt: this.buildWorkflowPrompt(params.input.prompt, params.model),
      client_id: `matrix-${Date.now()}`
    };

    const response = await this.fetch(`${params.provider.baseUrl}/prompt`, {
      method: 'POST',
      body: JSON.stringify(workflowPayload)
    });

    const data = await response.json();
    return await this.pollWorkflowResult(params.provider, data.prompt_id);
  }

  private buildWorkflowPrompt(prompt: string, model: string): Record<string, unknown> { }
  private async pollWorkflowResult(provider, promptId: string): Promise<{ imageUrl: string }> { }
}
```

### 4.2 APIManager扩展

**修改文件**: `src/main/services/APIManager.ts`

**新增成员变量**（第34-40行）：
```typescript
private adapters: Map<string, BaseAdapter> = new Map();
```

**新增初始化**（第154-166行）：
```typescript
public async initialize(): Promise<void> {
  this.registerAdapters();
  await this.ensureConfigDir();
  await this.loadProviders();
  if (this.providers.size === 0) {
    await this.registerDefaultProviders();
  }
  await this.checkAllProvidersHealth();
}

private registerAdapters(): void {
  this.adapters.set('openai-compatible', new OpenAICompatibleAdapter());
  this.adapters.set('async-polling', new AsyncPollingAdapter());
  this.adapters.set('comfyui-workflow', new ComfyUIWorkflowAdapter());
}
```

**新增核心方法**（第777行后）：
```typescript
public async callModel(params: {
  model: string;
  category: APICategory;
  input: Record<string, unknown>;
  providerId?: string;
}): Promise<unknown> {
  const { model, category, input, providerId } = params;

  let targetProvider: APIProviderConfig | undefined;

  if (providerId) {
    targetProvider = this.providers.get(providerId);
    if (!targetProvider) {
      throw new Error(`Provider ${providerId} 不存在`);
    }
  } else {
    const candidates = Array.from(this.providers.values()).filter(
      p => p.enabled && p.category === category && p.models?.includes(model)
    );

    if (candidates.length === 0) {
      throw new Error(`未找到支持模型 ${model} 的 ${category} Provider`);
    }

    candidates.sort((a, b) => (b.priority ?? 0) - (a.priority ?? 0));
    targetProvider = candidates[0];
  }

  const adapter = this.adapters.get(targetProvider.apiFormat);
  if (!adapter) {
    throw new Error(`不支持的API格式: ${targetProvider.apiFormat}`);
  }

  await logger.info(`调用模型 ${model}`, 'APIManager', {
    provider: targetProvider.name,
    format: targetProvider.apiFormat
  });

  return await adapter.callAPI({
    provider: targetProvider,
    model,
    input
  });
}

private async checkAllProvidersHealth(): Promise<void> {
  const providers = Array.from(this.providers.values());
  for (const provider of providers) {
    try {
      const status = await this.getProviderStatus(provider.id);
      if (status.status === 'unavailable' && provider.enabled) {
        provider.enabled = false;
        await this.addProvider(provider);
        await logger.warn(`Provider ${provider.name} 不可用，已自动禁用`, 'APIManager');
      }
    } catch (error) {
      await logger.error(`健康检查失败: ${provider.name}`, 'APIManager', { error });
    }
  }
}
```

### 4.3 现有硬编码方法处理

**处理策略**：备份 → 抽象 → 替换 → 清理

**现有硬编码方法**：
- `APIManager.callT8StarImage()` - T8Star 图像生成
- `APIManager.callT8StarVideo()` - T8Star 视频生成
- `APIManager.callRunningHubWorkflow()` - RunningHub 工作流（保留，工作流模式不同）

**处理步骤**：

```
阶段 1: 备份
- 将 callT8StarImage/callT8StarVideo 方法体备份为注释或 .bak 文件
- 目的：保留原有逻辑供参考

阶段 2: 抽象
- 将 callT8StarImage 的逻辑抽象到 OpenAICompatibleAdapter.callImageGeneration()
- 将 callT8StarVideo 的逻辑抽象到 OpenAICompatibleAdapter.callVideoGeneration()
- 将异步轮询逻辑抽象到 AsyncPollingAdapter

阶段 3: 替换
- callModel() 根据 apiFormat 调用对应 Adapter
- 插件改用 apiManager.callModel()
- 旧方法添加 @deprecated 标记，内部调用 callModel()

阶段 4: 清理（后续版本）
- 确认无直接调用后删除 @deprecated 方法
```

**过渡期兼容**：
```typescript
/**
 * @deprecated 请使用 callModel() 替代
 */
public async callT8StarImage(prompt: string, options?: {...}): Promise<string> {
  const result = await this.callModel({
    model: options?.model ?? 'nano-banana',
    category: APICategory.IMAGE_GENERATION,
    input: { prompt, ...options }
  });
  return result.imageUrl;
}
```

### 4.4 模型名称映射机制

**设计原则**（用户确认）：
- 插件层只关心功能类型，**不关心具体模型名称**
- 用户在 Settings 选择供应商 → 刷出该供应商支持的模型列表 → 选定一个
- **Adapter 层负责供应商特定的模型名称映射**

**映射流程**：
```
用户选择: sora-2 (通用名称)
     ↓
APIManager.callModel({ model: 'sora-2' })
     ↓
找到支持 sora-2 的 Provider（例如 JiekouAI）
     ↓
根据 Provider.apiFormat 选择 Adapter（AsyncPollingAdapter）
     ↓
Adapter 内部映射: sora-2 → sora-2-video-reverse（供应商特定名称）
     ↓
执行 API 调用
```

**示例（AsyncPollingAdapter 中的映射）**：
```typescript
private getEndpointByModel(model: string): string {
  // 供应商特定的模型名称映射
  const modelMapping: Record<string, string> = {
    'sora-2': 'sora-2-video-reverse',      // JiekouAI 的 Sora-2
    'sora-2-hd': 'sora-2-hd-video-reverse', // JiekouAI 的 Sora-2 HD
    'z-image-turbo': 'z-image-turbo',       // 无需映射
  };

  const mappedModel = modelMapping[model] || model;
  return `https://api.jiekou.ai/v3/async/${mappedModel}`;
}
```

**好处**：
- 插件代码简洁，无需了解各供应商的模型命名差异
- 切换供应商时，只需更新 Provider 配置，无需修改插件代码
- 未来支持本地模型（Ollama、ComfyUI）时，只需添加新 Adapter

### 4.5 类型扩展

**修改文件**: `src/shared/types/api.ts`

**扩展APIProviderConfig**（第37-66行）：
```typescript
export interface APIProviderConfig {
  id: string;
  name: string;
  category: APICategory;
  baseUrl: string;
  authType: AuthType;
  apiKey?: string;
  enabled: boolean;

  apiFormat: 'openai-compatible' | 'async-polling' | 'comfyui-workflow' | 'custom';

  models?: string[];
  priority?: number;

  costPerUnit?: number;
  currency?: string;
  timeout?: number;
  headers?: Record<string, string>;
  workflowId?: string;

  description?: string;
  createdAt?: string;
  updatedAt?: string;

  lastStatus?: 'available' | 'unavailable' | 'unknown';
  lastChecked?: string;
  lastLatency?: number;
}
```

---

## 五、插件层重构

### 5.1 配置文件简化

**文件**: `plugins/official/novel-to-video/default-config.json`

**完全替换为**：
```json
{
  "version": "1.0.0",
  "models": {
    "llm": "gpt-4",
    "imageGeneration": "sd3-large",
    "i2i": "nano-banana-pro",
    "videoGeneration": "sora-2"
  },
  "fallbackModels": {
    "llm": ["gpt-3.5-turbo", "deepseek-chat"],
    "imageGeneration": ["flux-1", "sdxl"],
    "videoGeneration": ["runway-gen3"]
  },
  "workflow": {
    "gates": {
      "stage2": ["characterImages", "sceneImages"],
      "stage2.5": ["sceneSummaries"],
      "stage3": ["storyboards"],
      "stage4": ["storyboardImages", "videoSegments"]
    }
  }
}
```

### 5.2 API服务重构

**文件**: `plugins/official/novel-to-video/src/services/NovelVideoAPIService.ts`

**删除**：
- 第11行：`import { JiekouAIProvider } from './providers/JiekouAIProvider';`
- 第52-73行：`registerProviders()` 方法
- 第99-115行：默认Provider ID fallback配置

**修改类型定义**（第13-33行）：
```typescript
interface PluginConfig {
  models: {
    llm: string;
    imageGeneration: string;
    i2i: string;
    videoGeneration: string;
  };
  fallbackModels?: {
    llm?: string[];
    imageGeneration?: string[];
    videoGeneration?: string[];
  };
}
```

**重构API调用方法**（第160行起）：
```typescript
async generateSceneImage(projectId: string, sceneAssetPath: string): Promise<string> {
  await this.ensureInitialized(projectId);
  const scene = await this.assetHelper.getAsset(sceneAssetPath);
  const prompt = scene.customFields?.novelVideo?.imagePrompt;

  if (!prompt) {
    throw new Error('场景缺少imagePrompt字段');
  }

  const model = this.pluginConfig.models.imageGeneration;

  const result = await this.apiManager.callModel({
    model,
    category: 'image-generation',
    input: { prompt, size: '1024x1024' }
  });

  return result.imageUrl;
}

async generateVideo(projectId: string, storyboardAssetPath: string): Promise<string> {
  await this.ensureInitialized(projectId);
  const storyboard = await this.assetHelper.getAsset(storyboardAssetPath);
  const prompt = storyboard.customFields?.novelVideo?.videoPrompt;
  const imagePath = storyboard.customFields?.novelVideo?.referenceImage;

  const model = this.pluginConfig.models.videoGeneration;

  const result = await this.apiManager.callModel({
    model,
    category: 'video-generation',
    input: { prompt, imagePath }
  });

  return result.videoUrl;
}

async generateImageToImage(params: {
  prompt: string;
  images: string[];
  size?: string;
}): Promise<string> {
  await this.ensureInitialized(this.projectId!);
  const model = this.pluginConfig.models.i2i;

  const result = await this.apiManager.callModel({
    model,
    category: 'image-generation',
    input: {
      prompt: params.prompt,
      images: params.images,
      size: params.size ?? '1024*1024'
    }
  });

  return result.imageUrl;
}
```

### 5.3 工作流编排修正

**文件**: `plugins/official/novel-to-video/src/services/WorkflowExecutor.ts`

**状态**: 需要修正 - Stage 4 缺少视频生成

**问题**：
- `executeStage4()` 方法（第250-276行）只生成分镜图片
- `NovelVideoAPIService.generateStoryboardVideo()` 方法已实现（第300-376行）但从未被调用

**修正方式**：
```typescript
// 在 executeStage4 中添加视频生成
private async executeStage4(context: WorkflowContext): Promise<StageExecutionResult> {
  const stage3Output = context.progress.stages['stage3'];
  if (!stage3Output) {
    throw new Error('Stage 3输出不存在');
  }

  const storyboards = stage3Output.outputs.storyboards;

  // 1. 生成分镜图片（现有逻辑）
  const storyboardImages = await this.resourceService.generateI2IImages(
    storyboards.map((s: any) => ({
      prompt: s.customFields?.imagePrompts?.[0] || '',
      referenceImages: []
    })).filter((s: any) => s.prompt),
    '9x16'
  );

  // 2. 生成分镜视频（新增）
  const videoSegments = [];
  for (const storyboard of storyboards) {
    const video = await this.resourceService.generateStoryboardVideo(
      context.projectId,
      storyboard.filePath
    );
    videoSegments.push(video);
  }

  return {
    success: true,
    outputs: {
      storyboardImages,
      videoSegments  // 新增输出
    }
  };
}
```

**关键点**：
- 5阶段编排逻辑正确
- 阀门检查完整
- 依赖系统AsyncTaskManager
- **需新增 Stage 4 视频生成调用**

### 5.4 服务扩展

**文件**: `plugins/official/novel-to-video/src/services/StoryboardService.ts`

**新增方法**（第150行后）：
```typescript
async generateSceneSummaries(
  projectId: string,
  scenes: SceneAsset[]
): Promise<SceneSummary[]> {
  await this.ensureInitialized(projectId);
  const summaries: SceneSummary[] = [];
  const model = this.pluginConfig.models.llm;

  for (const scene of scenes) {
    const prompt = `请为以下场景生成100字左右的摘要，突出视觉要素和情感氛围：\n\n${scene.description}`;

    const result = await this.apiManager.callModel({
      model,
      category: 'llm',
      input: {
        messages: [{ role: 'user', content: prompt }],
        maxTokens: 200
      }
    });

    summaries.push({
      sceneId: scene.id,
      summary: result.text,
      createdAt: await this.timeService.getISOString()
    });
  }

  return summaries;
}
```

**修改方法签名**（约第200行）：
```typescript
async generateStoryboard(
  projectId: string,
  scene: SceneAsset,
  previousSummary?: string,
  nextSummary?: string
): Promise<Storyboard> {
  await this.ensureInitialized(projectId);
  const contextPrompt = previousSummary || nextSummary
    ? `\n【上下文参考】\n前一场景: ${previousSummary || '无'}\n后一场景: ${nextSummary || '无'}`
    : '';

  const model = this.pluginConfig.models.llm;
  const prompt = `生成场景的分镜脚本：\n${scene.description}${contextPrompt}`;

  const result = await this.apiManager.callModel({
    model,
    category: 'llm',
    input: {
      messages: [{ role: 'user', content: prompt }],
      maxTokens: 1000
    }
  });

  return { script: result.text };
}
```

---

## 六、实施顺序

### 阶段1: 系统层基础（P0）

1. **类型扩展**
   - 修改 `src/shared/types/api.ts` 新增apiFormat字段
   - 验证：`npm run build` 无错误

2. **适配器层**
   - 创建 `src/main/adapters/BaseAdapter.ts`
   - 创建 `src/main/adapters/OpenAICompatibleAdapter.ts`
   - 创建 `src/main/adapters/AsyncPollingAdapter.ts`
   - 创建 `src/main/adapters/ComfyUIWorkflowAdapter.ts`
   - 创建 `src/main/adapters/index.ts`（统一导出）
   - 验证：`npm run build` 无错误

3. **APIManager扩展**
   - 备份现有 `callT8StarImage()` / `callT8StarVideo()` 方法逻辑
   - 新增 adapters 成员变量
   - 新增 `registerAdapters()` 方法
   - 新增 `callModel()` 方法
   - 新增 `checkAllProvidersHealth()` 方法
   - 修改 `initialize()` 方法
   - 标记旧方法为 `@deprecated`，内部改为调用 `callModel()`
   - 验证：调用 callModel 成功路由

### 阶段2: 插件层清理（P0）

4. **删除错误实现**
   - 删除 `plugins/official/novel-to-video/src/services/providers/JiekouAIProvider.ts`
   - 删除 `plugins/official/novel-to-video/src/services/providers/` 目录
   - 验证：目录不存在

5. **配置简化**
   - 完全替换 `default-config.json`
   - 验证：无providerId字段

6. **NovelVideoAPIService重构**
   - 移除硬编码默认 Provider ID（第102-114行）
   - 移除 `if (providerId === 't8star-image')` 等供应商判断
   - 移除 `callRunningHubTTS` 相关代码（或改为抛出明确错误）
   - 修改 PluginConfig 类型为模型配置
   - 重构所有 API 调用方法使用 `apiManager.callModel()`
   - 验证：无硬编码供应商ID，无运行时错误风险

### 阶段3: 服务扩展（P1）

7. **StoryboardService扩展**
   - 新增generateSceneSummaries()方法
   - 修改generateStoryboard()签名
   - 验证：调用返回SceneSummary[]

8. **ResourceService扩展**
   - 新增generateI2IImages()方法
   - 验证：调用成功

### 阶段4: 验收测试（P1）

9. **功能验收**
   - 调用callModel()成功路由到正确Provider
   - Settings中切换Provider，插件自动使用新Provider
   - 启动应用，不可用Provider自动禁用
   - N8N工作流5阶段完整执行

10. **代码验收**
    - 插件目录无providers子目录
    - 插件代码无硬编码供应商ID
    - default-config.json无providerId字段
    - 适配器层完整实现

---

## 七、验收标准

### 功能验收
- [ ] 调用 `apiManager.callModel({ model: 'sora-2', category: 'video-generation', input: {...} })` 成功
- [ ] Settings中切换Provider（JiekouAI → T8Star），插件自动路由
- [ ] 启动应用，不可用Provider自动禁用
- [ ] N8N工作流Stage 1-4 + Stage 2.5完整执行
- [ ] 异步轮询机制正常（10秒间隔、10分钟超时）
- [ ] 阀门机制正确阻塞缺失产出

### 代码验收
- [ ] `plugins/official/novel-to-video/src/services/providers/` 目录不存在
- [ ] `default-config.json` 中搜索 `"providerId"` 返回0结果
- [ ] `NovelVideoAPIService.ts` 中搜索 `JiekouAIProvider` 返回0结果
- [ ] `NovelVideoAPIService.ts` 中搜索 `if (providerId ===` 返回0结果
- [ ] `NovelVideoAPIService.ts` 中搜索 `callRunningHubTTS` 返回0结果
- [ ] `src/main/adapters/` 目录包含4个适配器文件 + index.ts
- [ ] 适配器命名无供应商名称（如 `AsyncPollingAdapter` 而非 `JiekouAdapter`）
- [ ] `APIManager.ts` 包含 `callModel()` 方法
- [ ] `APIManager.ts` 中 `callT8StarImage/callT8StarVideo` 标记为 `@deprecated`
- [ ] `api.ts` 中 `APIProviderConfig` 包含 `apiFormat` 字段

### 质量验收
- [ ] `npm run build` 成功编译
- [ ] `npm run lint` 无错误
- [ ] `npm test` 全部通过

---

## 八、关键文件路径

### 新增文件（5个）
```
src/main/adapters/BaseAdapter.ts
src/main/adapters/OpenAICompatibleAdapter.ts
src/main/adapters/AsyncPollingAdapter.ts
src/main/adapters/ComfyUIWorkflowAdapter.ts
src/main/adapters/index.ts
```

### 删除文件/目录
```
plugins/official/novel-to-video/src/services/providers/ (整个目录，含 JiekouAIProvider.ts)
```

**说明**：JiekouAIProvider.ts 是死代码，从未被调用，直接删除整个目录

### 修改文件（7个）
```
src/shared/types/api.ts (第37-66行)
src/main/services/APIManager.ts (第34-40行, 第154-166行, 第777行后)
plugins/official/novel-to-video/default-config.json (完全替换)
plugins/official/novel-to-video/src/services/NovelVideoAPIService.ts (第11行, 第52-73行, 第99-115行, 第160行起, 第430行, 第467行)
plugins/official/novel-to-video/src/services/StoryboardService.ts (第150行后, 约第200行)
plugins/official/novel-to-video/src/services/ResourceService.ts (第200行后)
plugins/official/novel-to-video/src/services/WorkflowExecutor.ts (第250-276行 executeStage4 添加视频生成)
```

### 保持不变（1个）
```
plugins/official/novel-to-video/src/services/MaterialCollector.ts
```

---

**方案完成标志**：
- ✅ 系统层提供模型路由和API适配能力
- ✅ 插件层仅配置模型、调用统一接口
- ✅ 所有硬编码供应商ID删除
- ✅ N8N工作流5阶段完整对齐
- ✅ 架构分层清晰、职责明确
